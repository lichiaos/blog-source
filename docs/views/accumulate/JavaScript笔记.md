---
title: JavaScript笔记
date: 2018-03-16
tags:
  - 基础概念
categories:
  - frontEnd
author: 尘丶骁
---

## JavaScript 简介

_诞生记:_ 在拨号上网的时代, 校验表单只能将数据发送到服务器端才可以验证, 但是等待时间过长, 很是蛋疼.

1. 他是一种脚本语言, 直接可以执行源码.
2. 由 Brendan Eich 设计,借鉴了了多种语言.
3. 由 `ECMAScript` `DOM` `BOM` 三大部分组成.

### 基础语法

- 严格区分大小写, 开头必须是字母和下划线 和$
- JavaScript 忽略空白符和换行符
- 在语句结束的时候尽量不要省略 `;`
- 驼峰命名法
- 不能数字开头

### 常用的 API

1. 警告框: `alert()` --用户需要点击按钮才可以继续操作.
2. 确认框: `confirm()` --用户点击确认或者取消才可以继续
3. 输入框: `prompt()` --用户需要输入某个值,然后点击确认或者取消才可以继续.
4. 在控制台输出: `console` --将结果打印到控制台

### 变量

**定义** : 用来储存值或表达式.

**声明变量及赋值** : ` var num   = 5;` --声明一个名为`num` 的变量并把`5` 赋值给他.

**声明提前** : 如果声明在后,则它会自动提前,而只把值留下来.

**数据类型**

---

### 简单数据类型

1. `Number`-------任意的数字

   - 整数: 二进制(0-1) 八进制(0 - 7) 十六进制 ( 0 - F)
   - 浮点数:
   - 无穷大 : `Infinity`-正无穷大 `- Infinity` 负无穷大
     `NaN` : 0 / 0 的时候 或者是一个非数字字符串的时候都会是 NaN.

2. `String`---------任意字符串

   - 字符串类型,指的是用**双引号**或者**单引号**括起来的字符.**注意**是英文下的半角符号.

3. `Boolean`-------true / false

   - `true` : 表示逻辑上的 **对**;
   - `false` : 表示逻辑上的 **错;**

4. `Undefined` --------undefined

   - 只有一个值, 即`undefined`

   - ```js
     var v;
     alert(v); //弹出：undefined。 变量v声明但是没有赋值初始化，则为undefined
     alert(m); //m没有定义，直接使⽤会发⽣错误。
     ```

     ​

5. `Null`---------null

   - 第二个只有一个值得数据类型,即`null` 表示一个空指针对象.

### 数据类型转换

#### 显示转换

1. ##### 其他类型转`Number`

- 字符串转`Number` ===> 如果字符串里面都是数字则会转成对应得数字,否则`NaN`
- `boolean`转`Number`
  - `true` ==> `1`
  - `false`==> `0`
- `Undefinded` ==> `NaN`
- `Null` ===> `0`
  - **小技巧** :如果在一个数据前面加`+` 号 则会自动转为 数字类型.

##### 2.其他类型转`Boolean`

- 只有一下五个值会转成`false`,其余的都会转为`true`.
  - `0` `""` `NaN` `Undefined` `Null`

##### 3.其他类型转`String`

- 本身长什么样子转成字符串之后就会是什么样子.

##### 4.其他类型转`Undefinded`和`Null`

- 无法转换

---

## 运算符

### 一.算数运算符

1. `+` `-` `*` `/` `%`
   - `+` 当两边都不是字符串得时候进行数学计算. 如果有`NaN`则结果也是`NaN`
   - 字符串连接: 当一边为字符串得时候就会当作连接来使用

---

### 二. 比较运算符

1. 数字之间得比较就是 数学中得比较
2. 字符串得比较 : 就是字母表中得计算 前面得字母小于后面得字母.
3. true > false
4. 如果两边不同 则转换为数字后比较

- **特殊情况**
  - NaN 和任何数都不想等,尽管是他自己本身.
  - undefi 和 null 是相等得,
  - null 不等于 0

---

### 三. 三元运算符

1. 语法 : 表达式 1 ? 表达式 2 : 表达式 3

   - 如果表达是得逻辑值是`true`,则最终返回得是表达式 1 的值, 如果是`false`则最终返回的是表达式 2 的值.

   - 用法:

     ```js
     var msg =
       score >= 90
         ? "优秀"
         : score >= 80
         ? "良好"
         : score >= 70
         ? "一般"
         : "其他情况";
     ```

---

### 四. 逻辑运算符

1. && 与 只要有一个是 false,那么结果就是 false.
2. || 或 只要有一个 true , 那么结果就是 true.

- 如果第一个能决定最后的结果,那值就是第一个.
- 如果第一个不能决定最后的结果,那值就是第二个.

---

## 条件循环语句

1. `if语句` **用法**:`if(condition){}` `if(){}else{]`

2. `switch语句`

   **用法**:

   ```js
   switch (expressions){			只有switch语句中的expressions和case中的value
       case value1					对应,才会执行语句,碰到 break 之后会结束语句.
       //语句1
       break;
       case value2
       //语句2
       break;
       defult
       //defalue语句
   }
   ```

   3.`for循环`

   **语法**:

   ```js
   for(表达式1;表达式2;表达式3){
       //循环体
   }
   表达式1 : 控制循环的初始变量
   表达式2 : 如果结果式 true 则执行循环,如果式 false  则结束循环.
   表达式3 : 一般都是进行自增或者式自减的操作
   注意 :
   1. 三个表达式都可以省略,第二个表达式省略之后默认值为    true;
   2. 中间的分号不能省
   ```

   4. `while循环`

   **语法** :

   ```js
   while (condition) {
     //循环体
   }
   ```

   5. `dou... while` 循环

   **语法** :

   ```js
   dou{
   //循环体
   }
   while()            先执行循环,然后判断条件
   ```

   ​

---

## 函数

### 一.函数概述

1. **简介** :

- **函数就是封装一段代码,然后完成某种功能.**

- ​ **一种特别的对象(可以执行)**

- **为什么要使用函数 ?**

- **提高代码的复用.**
- **便于阅读**

​

2. **语法**;

```js
function 函数名(形参1 , 形参 2, .....){
    函数体
}
```

**说明** : 定义形参的时候只需要函数名不需要 var 声明.

**return 的作用**: 1.给调用者返回值. 2. 结束当前语句,(如果省略了 return 或者有 return 没有返回值则最后返回的值 是 undefined)

::: tip 重点
函数只有被调用,才会被执行.

​ 如果后面的函数名和前面的函数名重叠,则后定义的会覆盖前面定义的.
:::

---

### 二. 全局变量和局部变量

1. 全局变量: 在函数外声明. 作用于整个页面文档.

2. 局部变量:在函数内声明 . 只在局部的区域起作用,

   ​ 表示形参的变量也是局部变量.

   ​ 在函数的外部不能访问到局部变量.

::: tip 注意
函数只有被调用,才会被执行.

​ 如果后面的函数名和前面的函数名重叠,则后定义的会覆盖前面定义的.
:::

---

### 三.匿名函数

1. **作用** :封装一段代码,把本来得全局变量封装为局部变量,避免命名冲突.

### 四.函数的递归

1. **定义** ：函数自己调用自己.
2. 一定要有结束语句,否则会陷入死循环.

### 五.三个高阶的函数

1. `map:映射`
2. `filter:过滤`
3. `reduce:归纳`

---

## 对象

### 一. 对象的简介

1. **概念:**
   - 多个数据的封装体.(或者是一个保存数据的容器)
   - 一个对象代表现实中的一个食物,(比如一个人,有很多属性组成)
2. **为什么要使用对象 ?** 便于对多个数据进行同一个管理.
3. **对象的组成**
   - 属性 : 属性名(字符串)和属性值组成.
   - 方法: 一种特别的属性,属性值是函数.

### 1. 面向对象得三大特征

- 封装

  把客观事物封装成抽象得类或者具体得象,并且类或者对象可以把自己的数据和方法只让可信的类或者对象操作,对不可信的进行信息隐藏.

- 继承

  可以让某个类型的对象获得另一个类型的对象的属性的方法.

- 多态

  不同实例的相同方法在不同情形下有不同表现形式.多态机制使具有不同内部结构的对象可以共享相同的外部接口.

### 二. 对象的属性相关

1. **对象的字面量**

   {

   属性名 : 属性值,

   属性名 : 匿名函数,

   }

2. **访问对象的属性**

   对象 `.` 属性名

   对象`[ 属性名]` 如果使字符串则用双引号和单引号括起来.

   - 1. ==属性名包含特殊字符 : - 空格.==
     2. ==属性名不确定.==

3. **增加或者修改对象**

   对象.属性名 = 值.

4. **删除对象的属性**

   delete 对象.属性

5. **this 的两种使用方法.**

   - 对象.方法()
     - 方法中的 this 指的就是当前的对象
   - 构造函数()
     - 括号中的 this 指的是 new 出来的对象.
   - 函数()
     - 函数内的 this 指的是 window.
   - 函数的借调
     - A() A.call()
     - 每个函数 A 都有一个方法 call,使用这个这个方法,也可以调用函数 A,可以指

## 原型

### 一.原型的概念

每一个函数或者是对象都有一个默认的属性 `prototype` 然后这个原型指向一个对象,称为原型对象.原型对象里面也有一个属性`constructor` 表示构造器,他会指向函数对象

**原型的作用?** : 可以在原型中添加属性和方法被构造出来的函数共用.

**原型的使用** : 一般原型里面添加方法

```js
function Person(){
    this._init(opt);
}
Person.prototype = {
    _init : function{
        Object.assign(this,opt);
    },
    constructor : Person,
    speak : function(){
        console.log(this.name);
    },
    say : function(){

    }
}
var p1 = new person(name :"Bob" , nage : 12 ,sex : "男")
```

### 显示原型和隐式原型

```js
function Fn(){
    console.log(Fn.prototype);  //每个函数function都有一个prototype,即显示原型属性,默认指向一个空的object对象;
}
-----------------------------------
var fn = new Fn()
	console.log(fn.__proto__)   //每个实例对象都有一个一个__proto__,即隐式对象.
	----------------------------------
	console.log(Fn.protptype === fn.__proto__)  //对象的隐式原型的值与其对应的构造函数的显示原型的值相等.
```

### 原型链的一些相关

1. 如过读取对象的属性值,就会查找原型链
2. 设置对象的属相值的时候,则不会去查找原型链,如果自身没有此属性则会直接在添加.

## 数组

### 一. 数组的简介

**1. 什么是数组** ?

- 数组就是一些简单数据的有序结合, 里面可以包含任意数据.

**2.为什么要用数据组** ?

- 储存相同类型的数据时用变量或者是对象十分的不方便,所以用数组来表示

### **3.数组的用法?**

- 数组的创建
  - 字面量:`var arr = [element,index,self]`
  - 构造函数:`var arr = new Array()`

### **4.数组的遍历** `var arr = [112,4,325,5,344,534,3]`

- for 循环
  - `for(i = 0 ; i < arr.length ; i++)`
- for in (for in 遍历出来的是数组的下标)
- for of
- forEach
  - ` arr.forEach(function(e,i){``}) `

### **5.数组的转换**

- toString() `arr.toString` 把数组转换为字符串之后,每个元素再用逗号连接.
- join() `arr.join()` 把数组转换为字符串但是""中的符号可以自定义.

### 6.数组的一些常用方法

- 添加元素
  - 首位添加 : unshift 末尾添加: push
  - 首位删除: shift 末尾删除: pop
- 倒置数组 : `reverce`
- 连接数组 : `concat`
- 切割元素 `slice(from,to)`
  - `from`包括 `to`不包括 `to`可以省略 如果都省略则整个都会切下来
  - 返回的是一个新数组.
- 替换元素 : `splice(参数1,参数2,参数3)`
  - `参数1` 表示从那个下标开始 `参数2` 表示删除几个元素, `参数3`表示要增加的元素

### **7.数组的排序**

```js
arr.sort(function(a,b){
    retrun a - b     升序
    retrun b - a     降序
})
```

### **8.数组的去重**

```js
function toHeavy(arr){
    for(var i = 0 ;i <arr.length ; i++){
        var num = arr[i]
        for(j = arr.length - 1 j>=i+1 ; j--){
            if(num ==arr.[j])
            arr.splice(j , 1)
        }
    }
}
function toHeavy(){
    var set = new Set(arr);
    arr.length = 0;
    arr.push(...set);
}
```

---

## 字符串

### 一. 字符串的创建

- 字面量 `var s = ""`
- toString 转换函数 `var s = String(可以是任何参数)`

### 二.字符串的常用方法

| 方法                             |                        含义                         |
| -------------------------------- | :-------------------------------------------------: |
| s.charAt(index)                  |                返回的是下标中的字符                 |
| s[]                              |                     也可以访问                      |
| charcodeAt                       |                  返回的 Unicode 码                  |
| substring(start , stop)          |    返回的是区间下标内的字符,下标为负值会替换成 0    |
| slice(start,stop)                | 和 substring 的唯一区别就是把负值下标加上字符串长度 |
| substr(start , length)           |               标开始,定义长度的的字符               |
| toUpperCase`------`toLowerCase() |                     转换大小写                      |
| trim                             |              去除字符串首尾的空白字符               |

---

## 正则表达式

### 一.正则表达式的创建

1. `var re = new RegExp(s,"gi")`
2. 字面量 : `var re = /a/gi;`

### 二. 常用的方法

- `text()` : 匹配修饰符,如果有`g` 的话会从上次匹配到的位置开始继续匹配,如果没`g` 的话会从头开始匹配.
  - 如果匹配不 了,下次还是会从头开始,
  - `lastIndex` 这个属性记录上次匹配的位置
- `exec()` :会把匹配到的元素返回到数组,并包括`index` 和源码两个数型

### 三. 规则

| 字符  | 含义                                                     |
| ----- | :------------------------------------------------------- | --- |
| .     | 匹配任意的字符                                           |
| [123] | 要么 1 要么 2 要么 3                                     |
| [a-z] | 所有的小写字母                                           |
| [^a]  | 不是字母 a 当把 ^放在[]中的时候表示非                    |
| \d    | 匹配的所有的数字 ===[0-9]                                |
| \D    | 匹配所有的非数字 === [^0-9]                              |
| \w    | 匹配所有的单词字符 数字字母和下划线 ===[0-9a-zA-Z_]      |
| \W    | 匹配所有的非单词字符 非数字字母和下划线 ===[^0-9a-za-z_] |
| \s    | 匹配一个空白字符，包括空格、制表符、换页符和换行符。     |
| \S    | 匹配一个非空白字符                                       |
| ^a    | 以 a 开头                                                |
| a$    | 以 a 结尾.                                               |
| ?     | 表示 0 个或 1 个                                         |
| \*    | 表示 0 个或多个 >=0                                      |
| +     | 表示 1 个或多个 >=1                                      |
| {m}   | 正好 m 个                                                |
| m,    | m 个或多个>m                                             |
| m,n   | 至少 m 个, 最多 n 个                                     |
| ()    | 进行分组                                                 |
| 丨    | 或                                                       | =   |

### 四.支持正则表达是的四种字符串用法

```js
var s = "Abc123aBc";
alert(s.search(/abc/gi));
alert(s.search(/abc/gi)); // 即使设置的全局模式，每次search也是从开始向后查找
//match⽅法和正则表达式的exec()⽅法的作⽤是⼀样的，但是match会⼀次性把所有的匹配放在⼀个数组
中，全部返回
alert(s.match(/abc/gi)); // Abc,aBc
alert(s.replace(/[ab]/gi, "x")); //把a或b替换成x
var ss = s.split(/[0-9]+/gi); //⽤1个或多个数字切割。 Abc,aBc
```

`s.search`: 返回值是匹配到元素的下标,不管加不加`g` 都是从头开始找

`s.match` : 和`exce()` 的方法一样但是`match` 会吧匹配到的都放在一个数组中,全部返回.

`s.replace`(用\1 来捕获组, 用$1 来替换:替换满足正则表达式返回

`S.split:` 把满足的正则表达是切割出去,,,并返回一个字符串数组.

---

## BOM

### 定时器

- `setTimeout` : 在指点时间后执行函数里面的代码
- `setInterval`: 每隔一段时间后自动执行代码.

---

## DOM

### 节点(每个节点都是一个对象)

- 所有的节点都有三个共同的属性

  - nodeName : 节点名
  - nodeType :节点类型
  - nodeValue : 节点值

  **获取元素节点的多种方式**

  1. 根据 id 来获取`getElementById`
     - 给元素命名 ID 的时候,理论不重复,如果重复,找到的是第一个
  2. 根据 className 来查找元素`getElementsByClass`
     - 得到的是多个元素组成的类数组
  3. 根据标签名来获取 `getElementsByTagName`
     - 得到的也是多个元素组成的类数组(`array-like`)
  4. 通过 name 属性的值来获取 `getElementsByName`
     - 不常用,一般用来查找表单元素

  **html5 新增两种强大查找元素的方法:**

  1. `document.querySelector("")`
     - 只能找到满足选择器的第一个元
  2. `document.querySelectorAll`
     - 能找到满足的选择器的所有元素
     - 返回的是一个类数组(Nodelist 节点列表)

  ### 节点之间的关系

  - 父子节点
    - `childN0odes` 获取所以子节点
    - `firstChild` : 获取元素的第一个子节点
    - `lastChild` : 获取元素的最后一个子节点
    - `parentNode` : 获取元素的第一个父节点
  - 兄弟节点
    - `nextSbling` :获取元素的下一个兄弟节点
    - `previousSbling`: 获取元素的上个兄弟节点.

  ### 创建节点

  - 创建元素节点 :`createElement("元素名")` .
  - 创建文本节点:`createText("文本内容")`
  - 给一个元素追加`child` 节点.`appendChild` (new,old)
  - 在一个节点前增加一个节点.`insertBefore()`
  - 移除子节点 : `removeChild`
  - 替换子节点:`replaceChild`.
  - 克隆节点` node.cloneNode(true/false)`

- `getAttriblute` 获取属性值

- `setAttribute("属性名","属性值")` 设置属性值.

- `removeAttribute` 移除属性

- `interHTML` : 会返回所有的内容,如果有标签会把标签解析出来.

---

### 事件

- **事件流的三个阶段**

  - 捕获阶段
  - 处于目标阶段
  - 冒泡阶段( 默认都在冒泡阶段,因为冒泡阶段的兼容性更好)

- **事件的三要素**

  - 事件源(表示事件发生的那个元素的位置)
  - 事件对象(会把事件发生的坐标,事件类型封装到一个对象中)
  - 事件处理程序(监听器) - -执行的代码,都在函数内.

- **事件处理程序**

  - HTML 事件处理程序

  - DOM0 事件处理程序

    - 注册事件的时候总是以 on 开头---`btn.onclick`---`btn.onmouseover`
    - 去掉 dom0 事件 ------`btn.onclick = null`
    - 缺点:同一个类型的事件,只能有一个事件处理程序.

  - DOM 事件处理程序

    - 给元素追加监听器

    - 参数 1:事件的类型 参数 2:事件处理程序 参数 3:事件是否在捕获阶段触发事件

    - ```js
      btn.addEventlistener("click"function(){},true)
      ```

- **常用的一些时间**

  - `onresize` : 改变窗口大小时执行事件
  - `onscroll` :滚动滚动条时.
  - `onfocus` :获取焦点
  - `onblur` :失去焦点.(不冒泡)

  **鼠标事件**

  - `mouseover`: 鼠标进入某个区域
  - `mouseout` :鼠标从某个区域出来(这两个是冒泡的)
  - `mouseenter`
  - `mouseleave` (这两个是不冒泡的版本)
  - `mousemove` :鼠标移动

- **事件对象**(触发事件的时候都会有一个默认的`event` 参数)

  - `type : click`
  - `target` : 事件发生区域最内层的那个元素(处于目标阶段的那个元素)
  - `currentTarget` : 事件注册在谁身上就表示那个元素.
  - `stopPropagation()` :停止事件的进一步传播
  - `preventDefault` () :阻止事件的默认行为.
